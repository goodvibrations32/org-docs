#+TITLE: diss_summary
#+PROPERTY: header-args :tangle ~/Documents/dissertation/org-docs/src/org-Example.py
#+STARTUP: showeverything
#+AUTHOR: Nikos Papadakis, Nikolas Torosian

* DONE Here is a test for my diss in org mode
** Example for jupyter notebook

#+begin_src jupyter-python :session py :async yes
print ("Hallo world!")
#+end_src

#+RESULTS:
: Hallo world!


** Importing custom functions from new package pros_noisefiltering
#+begin_src jupyter-python :session py :async yes :results raw drawer

from pathlib import Path
from matplotlib import pyplot as plt
import scipy.signal as signal
import numpy as np
import pandas as pd

from nptdms import TdmsFile
import nptdms


import pros_noisefiltering as pnf
from pros_noisefiltering.gen_functions import (spect,plot_spect_comb2,plot_FFT,
                                               Signals_for_fft_plot, Fft_Plot_info, Axis_titles)

from pros_noisefiltering.WT_NoiProc import WT_NoiseChannelProc
from pros_noisefiltering.Graph_data_container import Graph_data_container
#+end_src

#+RESULTS:
:results:
:end:


* This file is for comparing the spectrum of a filtered time series

** The first 3 plots are a comparison between the signals with the compressed air.
*** Here the signals are compared with respect of the Inverter state
1) *on/off*


*** Extra functions
#+begin_src jupyter-python :session py :async yes :results raw drawer
def apply_filter(ds:np.ndarray, fs_Hz:float, fc_Hz = 100, filt_order = 2 ):
                 # filter cutoff frequency
    sos = signal.butter(filt_order , fc_Hz, 'lp', fs=fs_Hz, output='sos')
    filtered = signal.sosfilt(sos, ds-ds[0])+ds[0]
    return filtered

#CONSTANTS
#+end_src

#+RESULTS:
:results:
:end:


*** Compressed air measurements
**** Constant directories and names for the .tdms file structure

#+begin_src jupyter-python :session py :async yes :results raw drawer
FOLDER_FOR_DATA = Path('/mnt/data_folder')/'measurements_12_05_22/new_record_prop_channel/'
if not FOLDER_FOR_DATA.exists():
    FOLDER_FOR_DATA = Path('D:/_data/WEL/WEL20220512/')

TDMS_FNAME = 'Data.tdms'
#+end_src

#+RESULTS:
:results:
:end:


**** Compressed air measurements folder names for the path
***** Here the folder path is adjusted to use the compressed air measurements.
#+begin_src jupyter-python :session py :async yes :results raw drawer

# Dir names for the Compressed air measurment
comp_air_dir = 'compressed air'

# New renamed folders for rec version information
data_CA_inv_0_WS_0 = 'ca0_0.1'
data_CA_inv_0_WS_5 = 'ca0_5.1'
data_CA_inv_0_WS_11= 'ca0_10.1'
data_CA_inv_1_WS_0 = 'ca1_0.1'
data_CA_inv_1_WS_5 = 'ca1_5.1'
data_CA_inv_1_WS_10= 'ca1_10.1'

path_comp = FOLDER_FOR_DATA / comp_air_dir

# CA stands for compressed air

raw_signal_CA = [data_CA_inv_0_WS_0, data_CA_inv_0_WS_5,
                data_CA_inv_0_WS_11, data_CA_inv_1_WS_0,
                data_CA_inv_1_WS_5, data_CA_inv_1_WS_10 ]
#+end_src

#+RESULTS:
:results:
:end:

***** Initiate an object for the tdms files for the compressed air

#+begin_src jupyter-python :session py :async yes :results raw drawer
tdms_raw_CA = []

for item in raw_signal_CA:
    y = f'{path_comp}/{item}'
    x=TdmsFile( Path( y , TDMS_FNAME))
    tdms_raw_CA.append(x)

GROUP_NAME = 'Wind Measurement'
CHAN_NAME = 'Wind2'

#+end_src

#+RESULTS:
:results:
:end:

***** Objects with attributes from WT_NoiseChannelProc class
#+begin_src jupyter-python :session py :async yes :results raw drawer

df_tdms_i0_w0 = WT_NoiseChannelProc.from_tdms(tdms_raw_CA[0][GROUP_NAME][CHAN_NAME]
                , desc= 'Inverter off, WS=0')
df_tdms_i0_w5 = WT_NoiseChannelProc.from_tdms(tdms_raw_CA[1][GROUP_NAME][CHAN_NAME]
                , desc= 'Inverter off, WS=5')
df_tdms_i0_w10 = WT_NoiseChannelProc.from_tdms(tdms_raw_CA[2][GROUP_NAME][CHAN_NAME]
                , desc= 'Inverter off, WS=11')
df_tdms_i1_w0 = WT_NoiseChannelProc.from_tdms(tdms_raw_CA[3][GROUP_NAME][CHAN_NAME]
                , desc= 'Inverter on, WS=0')
df_tdms_i1_w5 = WT_NoiseChannelProc.from_tdms(tdms_raw_CA[4][GROUP_NAME][CHAN_NAME]
                , desc= 'Inverter on, WS=5')
df_tdms_i1_w10 = WT_NoiseChannelProc.from_tdms(tdms_raw_CA[5][GROUP_NAME][CHAN_NAME]
                , desc= 'Inverter on, WS=10')
#+end_src

#+RESULTS:
:results:
:end:


**** Plots for comparison and future work for this file
***** DONE Stuff
CLOSED: [2022-08-10 Τετ 12:24]
- [X] consider renaming df_tdms_i0_w0 to df_tdms_i0_w0
- [X] where i: inverter state
- [X] where w: wind speed
- [X] Estimate the power spectral density of the raw signal
- [X] Hotwire speed 0 m/s


***** Plot the power spectral density of the butterworth and the FIR combined with raw signal for comparison
#+begin_src jupyter-python :session py :async yes :results raw drawer
fc_Hz=2000
plot_spect_comb2([df_tdms_i0_w0.calc_spectrum(),
                df_tdms_i1_w0.calc_spectrum(),
                df_tdms_i1_w0.filter(fc_Hz=fc_Hz, filter_func=apply_filter).calc_spectrum(),],
                title='Comparison between power spectra at WS=0 ',
                     xlim =[1e2,1e5], ylim= [1e-7,1e-2],
                Kolmogorov_offset=1e3, to_disk=True)



# Estimate the power spectral density of the raw signal
# Hotwire speed 5 m/s

plot_spect_comb2([
                df_tdms_i0_w5.calc_spectrum(),
                df_tdms_i1_w5.calc_spectrum(),
                df_tdms_i1_w5.filter(fc_Hz=fc_Hz, filter_func=apply_filter).calc_spectrum()],
                title='Comparison between power spectra at WS=5 m/s ',
                xlim =[1e1,1e5], ylim= [1e-7, 1e-2],
                Kolmogorov_offset=1e2, to_disk=True)

# Estimate the power spectral density of the raw signal

# Hotwire speed 10/11 m/s

plot_spect_comb2([df_tdms_i0_w10.calc_spectrum(),
                df_tdms_i1_w10.calc_spectrum(),
                df_tdms_i1_w10.filter(fc_Hz=fc_Hz, filter_func=apply_filter).calc_spectrum()],
                title='Comparison between power spectra at WS=10 m/s ',
                     xlim =[1e1,1e5],
                Kolmogorov_offset=1e2, to_disk=True)

plt.show()
#+end_src

#+RESULTS:
:results:
[[file:./.ob-jupyter/77ec48fe72dbcb7d531dc428537a8d79926fd55b.png]]
[[file:./.ob-jupyter/6527bc87ae2da6f0ed6426dd21010696701650e4.png]]
[[file:./.ob-jupyter/bbb6c7664a2c4da30d1d0fe7afe4fac94de929ef.png]]
:end:




*** Wind tunnel measurements from june

**** folder structure for inverter measurements

#+begin_src jupyter-python :session py :async yes :results raw drawer
#%% CONSTANTS
FIGSIZE_STD = (6,6)
#Constant directories and names for the .tdms file structure
# Dir name
TDMS_FNAME = 'Data.tdms'
GROUP_NAME = 'Wind Measurement'
CHAN_NAME = 'Wind2'

#%%
inv_meas_dir = 'inverter'
# Inverter measurements of interest
data_inv_inv_0_WS_0= 'in0_0.1'
data_inv_inv_1_WS_0 = 'in1_0.1'
data_inv_inv_1_WS_5 = 'in1_5.1'
data_inv_inv_1_WS10= 'in1_10.1'
data_inv_inv_1_WS15 = 'in1_15.1'
data_inv_inv_1_WS_20 = 'in1_20.1'


path_comp = FOLDER_FOR_DATA / inv_meas_dir

# suffixes:
# - CA : compressed air
# - Inv : Inverter
# - DEC : decimation

raw_signal_CA = [data_inv_inv_0_WS_0, data_inv_inv_1_WS_0,
                 data_inv_inv_1_WS_5,
                data_inv_inv_1_WS10, data_inv_inv_1_WS15,
                data_inv_inv_1_WS_20 ]

l_tdms_Inv = []

for item in raw_signal_CA:
    x=TdmsFile( Path( f'{path_comp}/{item}' , TDMS_FNAME))
    l_tdms_Inv.append(x)

#%%
[print(x) for x in l_tdms_Inv[0][GROUP_NAME].channels()]


#+end_src

#+RESULTS:
:results:
: <TdmsChannel with path /'Wind Measurement'/'Torque'>
: <TdmsChannel with path /'Wind Measurement'/'Drag'>
: <TdmsChannel with path /'Wind Measurement'/'Wind1'>
: <TdmsChannel with path /'Wind Measurement'/'Wind2'>
|---|
|---|
|---|
|---|
:end:


**** Construction of objecs
+ Here we store some information with the help of object oriented programing to a variable for later use. This is making the overall process much faster in performance and reusage terms.

#+begin_src jupyter-python :session py :async yes :results raw drawer

dfi_i0_w0 = WT_NoiseChannelProc.from_tdms(l_tdms_Inv[0][GROUP_NAME][CHAN_NAME]
                , desc= 'Inverter Off, WS=0, 100kHz')
dfi_i1_w0 = WT_NoiseChannelProc.from_tdms(l_tdms_Inv[1][GROUP_NAME][CHAN_NAME]
                , desc= 'Inverter On, WS=0, 100kHz')
dfi_i1_w5 = WT_NoiseChannelProc.from_tdms(l_tdms_Inv[2][GROUP_NAME][CHAN_NAME]
                , desc= 'Inverter On, WS=5, 100kHz')
dfi_i1_w10 = WT_NoiseChannelProc.from_tdms(l_tdms_Inv[3][GROUP_NAME][CHAN_NAME]
                , desc= 'Inverter On, WS=10, 100kHz')
dfi_i1_w15 = WT_NoiseChannelProc.from_tdms(l_tdms_Inv[4][GROUP_NAME][CHAN_NAME]
                , desc= 'Inverter On, WS=15, 100kHz')
dfi_i1_w20 = WT_NoiseChannelProc.from_tdms(l_tdms_Inv[5][GROUP_NAME][CHAN_NAME]
                , desc= 'Inverter On, WS=20, 100kHz')

#+end_src

#+RESULTS:
:results:
:end:


**** Signal in frequency domain
***** My first fft approach
- Here the algorithm used for calculating the freq bandwidth and plotting the signal in frequency domain is a black box and sould be replaced with something more reliable.
  /Reference/ : https://www.youtube.com/watch?v=O0Y8FChBaFU

 
****** Calculation of fft for 2 signals with first approach

#+begin_src jupyter-python :session py :async yes :results raw drawer

# here the plots are comparing the raw signals.
# First plot is with the inverter state off and on and ws 0
f, yin,yout = pnf.gen_functions.fft_sig([pnf.gen_functions.fft_calc_sig(dfi_i0_w0.data,
                                            dfi_i1_w0.data, label="inv on")])

# here the inverter is on and the ws is 5, 10 (1st and 2nd graph respectively)
f1, yin1,yout1 = pnf.gen_functions.fft_sig([pnf.gen_functions.fft_calc_sig(dfi_i1_w5.data,
                                            dfi_i1_w10.data, label="inv on")])

# here the inverter is on and the ws is 15, 20 (1st and 2nd graph respectively)
f2, yin2,yout2 = pnf.gen_functions.fft_sig([pnf.gen_functions.fft_calc_sig(dfi_i1_w15.data,
                                            dfi_i1_w20.data, label="inv on")])


ws0 = [f,yin,yout]

ws5 = [f1,yin1,yout1]

ws10 = [f2,yin2,yout2]

data_list = [ws0,ws5,ws10]

# %%
ws_list = ['ws-0','ws-5/10','ws-15/20']


#+end_src

#+RESULTS:
:results:
:end:

****** Plots of raw signals in frequency domain

#+begin_src jupyter-python :session py :async yes :results raw drawer

for item,descr_sig in zip(data_list,ws_list):
    plot_FFT([Signals_for_fft_plot(freq=item[0], sig1=item[1], sig2= item[2]),],

         [Fft_Plot_info(Title="Inverter off/on",
                       filter_type='',
                       signal_state=f'raw-{descr_sig}-on')     ],

         [Axis_titles('Frequency [Hz]', 'Amplitute [dB]')    ]
                )


plt.show()


#+end_src

#+RESULTS:
:results:
[[file:./.ob-jupyter/0e14ebc6bae952d1af52337c2003a59f24ff40f1.png]]
[[file:./.ob-jupyter/1f498f67e9d7c3ed25fc50750ab228b3b75a56fc.png]]
[[file:./.ob-jupyter/1981ee15aee0dfe186afcb0be41a0eec44b12eed.png]]
:end:

****** TODO POWER SPECTRAL DENCITY

#+begin_src jupyter-python :session py :async yes :results raw drawer




#+end_src


***** Yet another fft algorithm
Here a new algorithm is tested but the results are not promissing
reference : https://www.youtube.com/watch?v=s2K1JfNR7Sc

****** Time information (interval and array)

#+begin_src jupyter-python :session py :async yes :results raw drawer

from numpy.fft import fft, ifft
Sr = len(dfi_i1_w0.data_as_Series.index)
dt = 1 / int(Sr)
print (f"The time interval of the measurement is:\n{dt}")

time_s = np.arange(0,7,dt)
print(f"The time array is: \n {time_s}")
#+end_src

#+RESULTS:
:results:
: The time interval of the measurement is:
: 1.8518518518518519e-06
: The time array is:
:  [0.00000000e+00 1.85185185e-06 3.70370370e-06 ... 6.99999444e+00
:  6.99999630e+00 6.99999815e+00]
:end:

****** MODS FFT algorithm

#+begin_src jupyter-python :session py :async yes :results raw drawer

n= len(time_s)
fhat = fft(dfi_i1_w0.data,n)                              # compute fft
PSD = fhat * np.conj(fhat) / n               # Power spectrum (power/freq)
freq = (1/(dt*n)) * np.arange(n)             # create x-axis (frequencies)
L = np.arange(1,np.floor(n/2),dtype=int)     # plot only first half (possitive

print(f"This is the length of the time array and should be = 2_650_000 >< no {n}")

#+end_src

#+RESULTS:
:results:
: This is the length of the time array and should be = 2_650_000 >< no 3780000
:end:

****** MODS Plot with errors of raw signal in frequency domain

#+begin_src jupyter-python :session py :async yes :results raw drawer
plt.rcParams ['figure.figsize'] =[16,12]
plt.rcParams.update ({'font.size': 18})

fig, axs = plt.subplots(2,1)

plt.sca(axs[0])
#plt.plot(time_s,df_tdms_i0_w0.data)
plt.loglog(freq,np.sqrt(PSD))

plt.sca(axs[1])
plt.plot(freq[L],abs(PSD[L]))
#plt.xscale('log')
plt.yscale('log')
plt.xscale('log')
plt.show()
print (df_tdms_i1_w0.data_as_Series, df_tdms_1_0.data)

#+end_src

#+RESULTS:
:results:
: /usr/lib/python3.10/site-packages/matplotlib/cbook/__init__.py:1298: ComplexWarning: Casting complex values to real discards the imaginary part
:   return np.asarray(x, float)
[[file:./.ob-jupyter/8aad75b1bb0eed54a45b5cdc279ebd7298af81f2.png]]
#+begin_example
0          1.620280
1          1.618670
2          1.616738
3          1.616094
4          1.619314
             ...
3099995    1.629619
3099996    1.618992
3099997    1.624788
3099998    1.618348
3099999    1.622534
Name: Wind2:raw, Length: 3100000, dtype: float64 [1.62028023 1.61867018 1.61673812 ... 1.62478838 1.61834817 1.6225343 ]
#+end_example
:end:

****** TODO POWER SPECTRAL DENCITY

#+begin_src jupyter-python :session py :async yes :results raw drawer




#+end_src

****** DONE Add proper implementation of new algorithm for our case
CLOSED: [2022-08-10 Τετ 11:53]
This is added because of /aliasing effect/ and some initial problems that occured during comparison between the wind tunnel measurements and the Compressed Air.
+ The class FFT_new is taking advantage of the constructed object here the "signal" with some information derived straight from the above process.

#+begin_src jupyter-python :session py :async yes :results raw drawer

from numpy.fft import fft, ifft
#%%
# TODO Make this in a class with functions so there is no problem with migrating
# this fft algorithm to pypkg and remove duplicate code (redundancy)
#
class FFT_new:
    def __init__(self, signal):
        self.sr = signal.fs_Hz
        self.sig = signal.data
        self.ind = signal.data_as_Series.index
        self.dt = 1/ int(self.sr)
        self.time_sec = self.ind * self.dt


    def fft_calc_and_plot(self):
        n= len(self.time_sec)
        fhat = fft(self.sig,n)                 # compute fft
        PSD = fhat * np.conj(fhat) / n               # Power spectrum (power/freq)
        freq = (1/(self.dt*n)) * np.arange(n)             # create x-axis (frequencies)
        L = np.arange(1,np.floor(n/2),dtype=int)     # plot only first half (possitive)

        fig, axs = plt.subplots(2,1)

        plt.sca(axs[0])
        plt.grid('both')
        plt.title('Time domain of raw signal')
        plt.xlabel('Time [s]')
        plt.ylabel('Amplitute (Voltage)')
        plt.plot(self.time_sec ,self.sig)
        #plt.loglog(freq[L],(PSD[L]))

        plt.sca(axs[1])
        plt.loglog(freq[L],abs(PSD[L]))
        plt.title('Frequency domain')
        plt.xlabel('Frequencies [Hz]')
        plt.ylabel('Power/Freq')
        plt.grid('both')
        plt.show()

# Sample usage for plotting
FFT_new(dfi_i0_w0).fft_calc_and_plot()




#+end_src

#+RESULTS:
:results:
[[file:./.ob-jupyter/963e8d96925278d6d3da94b2954922684944c905.png]]
:end:
